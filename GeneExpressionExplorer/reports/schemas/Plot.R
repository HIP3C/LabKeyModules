#  Copyright 2014 Fred Hutchinson Cancer Research Center
#
#  Licensed under the Apache License, Version 2.0 (the 'License');
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an 'AS IS' BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.


suppressMessages( library( Cairo ) );
suppressMessages( library( RJSONIO ) );
library(ggplot2)
library(data.table)
library(Rlabkey)
library(reshape2)

merge_cohorts <- function(x, y){
  return(merge(x, y, by="gene_symbol"))
}

get_cohort_expression <- function(pd){
  umat <- unique(pd[, list(run_dataoutputs_name, run_featureset)])
  files <- file.path(labkey.file.root, "analysis/exprs_matrices/", umat$run_dataoutputs_name)
  EM <- vector('list', nrow(umat))
  for(i in 1:nrow(umat)){
    header <- scan(files[i], what = "character", nlines = 1, sep = "\t", quiet = TRUE)
    em <- fread(files[i])
    setnames(em, colnames(em), c("feature_id", header))
    #TODO: get the gene symbols
  f2g <- data.table(labkey.selectRows(labkey.url.base, labkey.url.path, "Microarray", "FeatureAnnotation",
                           colFilter = makeFilter(c("FeatureAnnotationSetId", "IN", 
                                                    paste(umat$run_featureset[i], collapse=";"))),
                           colNameOpt = "rname"))
    em <- em[, gene_symbol := f2g[match(em$feature_id, f2g$featureid), genesymbol]]
    em <- em[, lapply(.SD, mean), by="gene_symbol", .SDcols=2:(ncol(em)-1)]
    EM[[i]] <- em
  }
  EM <- Reduce(f=merge_cohorts,EM)
  return(EM)
}


imageWidth  <- as.numeric(labkey.url.params$imageWidth);
imageHeight <- as.numeric(labkey.url.params$imageHeight);
CairoPNG( filename='${imgout:Plot.png}', width = imageWidth, height = imageHeight );

response            <- labkey.url.params$response;
arrayCohorts        <- RJSONIO::fromJSON( labkey.url.params$cohorts );
response            <- as.character( labkey.url.params$response );
timePoint           <- as.numeric( labkey.url.params$timePoint );
timePointDisplay    <- labkey.url.params$timePointDisplay;
arrayGenes          <- RJSONIO::fromJSON( labkey.url.params$genes );
textSize            <- as.numeric( labkey.url.params$textSize );
facet               <- tolower(labkey.url.params$facet)
shape               <- tolower(labkey.url.params$shape)
color               <- tolower(labkey.url.params$color)
size                <- tolower(labkey.url.params$size)
alpha               <- tolower(labkey.url.params$alpha)

stopcheck <- function(data){
    stop(paste(apply(as.matrix(data), 1, function(x){ paste(x, collapse=",")}), collapse="\n"))
}

if(exists("loadedCohorts") && all(loadedCohorts == arrayCohorts)){
  #No need to read again
} else{
  cohort_filter <- makeFilter(c("biosample_arm_name", "IN", paste(arrayCohorts, collapse=";")))
  gem <- data.table(labkey.selectRows(baseUrl=labkey.url.base, folderPath=labkey.url.path,
                                      schemaName="assay.ExpressionMatrix.matrix",
                                      queryName = "InputSamples", viewName = "gene_expression_matrices",
                                      colFilter = cohort_filter, colNameOpt = "rname"))
  setnames(gem, colnames(gem), gsub("^biosample_", "", colnames(gem)))
  gem <- unique(gem[arm_name %in% arrayCohorts])

  #gem <- data.table(labkey.selectRows(baseUrl=labkey.url.base, folderPath=labkey.url.path, schemaName="study",
  #                                    queryName="gene_expression_matrices", colFilter=cohort_filter, 
  #                                    viewName = "ImmuneResponsePredictor.gene_expression_matrices",
  #                                    colNameOpt="rname"))
  demographics <- data.table(labkey.selectRows(baseUrl=labkey.url.base, folderPath=labkey.url.path, schemaName="study", 
                                      queryName="demographics", colNameOpt="rname"))
  demographics <- demographics[, list(subject_accession, age_reported, gender, race)] 
  setnames(demographics, "age_reported", "age")
  gem <- merge(gem, demographics, by="subject_accession")
  # Subjects with all timepoints
  utp <- unique(gem$study_time_collected)
  gem <- gem[, keep:=(sum(study_time_collected %in% utp) == length(utp)), by="subject_accession"]
  gem <- gem[keep==TRUE]
  pd <- gem[order(subject_accession, study_time_collected)]
  # Get HAI
  hai_filter <- makeFilter(c("subject_accession", "IN", paste(pd$subject_accession, collapse=";")))
  hai <- data.table(labkey.selectRows(baseUrl=labkey.url.base, folderPath=labkey.url.path, schemaName="study", 
                                      #viewName = "ImmuneResponsePredictor.hai",
                                      queryName="hai", colFilter=hai_filter, colNameOpt="rname"))
  #hai <- hai[is.na(biosample_accession_name), biosample_accession_name := "missing"]
  hai <- hai[, list(subject_accession, study_time_collected, response=value_reported/value_reported[study_time_collected==0]), by="virus_strain,subject_accession"]
  hai <- hai[study_time_collected==28]
  hai <- hai[, list(response=log2(max(response))), by="subject_accession"]
  EM <- get_cohort_expression(pd)
  EM <- EM[, c("gene_symbol", colnames(EM)[ colnames(EM) %in% pd$biosample_accession]), with=FALSE]
}

# Subsets
ssES <- EM[gene_symbol %in% arrayGenes]
if(timePoint == 0){
  FC <- ssES[, pd[study_time_collected == 0, biosample_accession], with=FALSE]
  xlab <- "log expression"
} else{
  FC <- ssES[, pd[study_time_collected == timePoint, biosample_accession], with=FALSE] -
        ssES[, pd[study_time_collected == 0, biosample_accession], with=FALSE]
  xlab <- paste("log Fold-Change with respect to baseline")
}
FC <- FC[, gene:=ssES$gene_symbol]
FC <- melt(FC, id="gene")
FC <- data.table(FC)
setnames(FC, c("variable", "value"), c("biosample_accession", "logFC"))
data <- merge(FC, pd, by="biosample_accession")[, list(biosample_accession, gene, subject_accession, logFC, arm_name, age, race, gender)]
#data <- data[is.na(biosample_accession_name), biosample_accession_name := "missing"]
data <- merge(data, hai, by=c("subject_accession"))

# Plot
if(color=="") color <- NULL
if(shape=="") shape <- NULL
if(size=="") size <- NULL
if(alpha=="") alpha <- NULL
p <- ggplot(data=data, aes(x=logFC, y=response)) + geom_point(aes_string(size=size, color=color, alpha=alpha, shape=shape)) + geom_smooth(method="lm") + ylab(response) + xlab(xlab) + theme(text=element_text(size=textSize))
if(facet == "grid"){
  p <- p + facet_grid(aes(arm_name, gene), scales="free")
} else{
  p <- p + facet_wrap(~arm_name + gene, scales="free")
}
print(p)

loadedCohorts <- arrayCohorts
dev.off();

Sys.sleep(3);

write( RJSONIO::toJSON( x=arrayCohorts, asIs = T ), '${jsonout:outArray}' );
