```{r knitr_opts, echo = FALSE, cache = FALSE}
library(knitr)
opts_chunk$set(cache = FALSE, cache.path = file.path(labkey.file.root, "cache/DifferentialExpressionAnalysis/"))
opts_chunk$set(echo = FALSE, message = FALSE)
```

```{r libraries, message = FALSE, echo = FALSE, warning = FALSE}
library(Rlabkey)
library(ImmuneSpaceR)
library(limma)
library(Biobase)
library(data.table)
library(gtools)
library(DT)
```

```{r parameters}
contrast <- c("study_time_collected", "study_time_collected_unit")
study <- basename(labkey.url.path)
```

## Differential expression analysis

Returns genes differentially expressed with an FDR of less than 20%, or top 100 lowest FDR.

study: `r study`  
contrast: `r contrast`

```{r getData, warning = FALSE}
con <- CreateConnection(study)

if (is.null(con$cache[["GE_matrices"]])) {
  warning("There is no HIPCMatrix run in this study")
  opts_chunk$set(eval = FALSE, echo = FALSE)
}

# create df of cohorts and timepoints
con$getGEInputs()
coefs <- unique(con$cache$GE_inputs[, c("arm_name", contrast), with = FALSE])
coefs <- coefs[study_time_collected > 0]
message(paste("There will be", nrow(coefs), "differential expression analysis."))
```

```{r analysis}
idx <- 1

GEA_list <- vector("list")
GEAR_list <- vector("list")

cm <- con$getDataset("cohort_membership")
cm <- unique(cm[, list(cohort, arm_accession)])

runs <- con$cache$GE_matrices[, list(cohort, name)]
setnames(runs, "cohort", "arm_name")

for (mx in runs$name) {

  EM <- con$getGEMatrix(matrixName = mx)
  pd <- data.table(pData(EM))
  pd <- pd[, coef := do.call(paste, .SD), .SDcols = contrast]
  to_drop <- unique(pd[study_time_collected <= 0, coef])
  pd <- pd[coef %in% to_drop, coef := "baseline"]
  tmp <- grep("baseline", value = TRUE, invert = TRUE, mixedsort(unique(pd$coef)))
  pd <- pd[, coef := factor(coef, levels = c("baseline", tmp))] # preps coef col for use in model
  mm <- model.matrix(formula("~participant_id + coef"), pd)

  if (max(exprs(EM)) > 100) { EM <- voom(EM) } # Check if it's RNA-seq or microarrays
  fit <- lmFit(EM, mm)
  fit <- eBayes(fit)

  timepoints <- grep("^coef", colnames(mm), value = TRUE)
  for (tp in timepoints) {
    analysis_accession <- paste0("GEA", idx )
    currTP <- gsub("coef", "", tp)
    arm_name <- unique(pd$cohort)
    arm_accession <- cm[ cohort == arm_name, arm_accession ]
    if (is.null(arm_name)){ arm_name <- NA }
    description <- paste0("Differential expression in ",
                          mx, ", ", currTP, " vs. baseline")

    GEA_list[[idx]] <- data.table(analysis_accession = analysis_accession,
                                  expression_matrix = mx,
                                  arm_name = arm_name,
                                  arm_accession = arm_accession,
                                  coefficient = currTP,
                                  description = description)

    tt <- data.table(topTable(fit, coef = tp, number = Inf))
    ttDE <- tt[adj.P.Val < 0.02]

    if (nrow(ttDE) < 100) {
      ttDE <- tt[order(adj.P.Val)][1:min(nrow(tt), 100)]
    }

    if (nrow(ttDE) > 0) {
      ttDE[, c("analysis_accession", "coefficient") := list(analysis_accession, currTP)]
      GEAR_list[[idx]] <- data.table(ttDE)
    }

    idx <- idx + 1
  }
}

GEA <- rbindlist(GEA_list)

if (length(GEAR_list) == 0) {
  warning("No feature was found to be differentially expressed at any timepoint.")
  opts_chunk$set(eval = FALSE, echo = FALSE)
} else {
  GEAR <- rbindlist(GEAR_list)
  setnames(GEAR,
           c("FeatureId", "gene_symbol", "adj.P.Val", "AveExpr", "logFC", "P.Value", "t"),
           c("feature_id", "gene_symbol", "adj_p_val", "ave_expr", "log_fc", "p_value", "statistic"))
}
```

```{r write}

if( length(GEA_list) > 0 ){
    # Set HTTP call vars
    baseUrl <- labkey.url.base
    folderPath <- labkey.url.path
    schemaGE <- "gene_expression"
    queryGEA <- "gene_expression_analysis"
    queryRes <- "gene_expression_analysis_results"

    # delete old GEA
    currGEA <- labkey.selectRows(baseUrl = baseUrl,
                                 folderPath = folderPath,
                                 schemaName = schemaGE,
                                 queryName = queryGEA,
                                 colNameOpt = "rname",
                                 showHidden = T)
    if( nrow(currGEA) != 0 ){
      deleteGEA <- labkey.deleteRows(baseUrl = baseUrl,
                                     folderPath = folderPath,
                                     schemaName = schemaGE,
                                     queryName = queryGEA,
                                     toDelete = currGEA)
      if( deleteGEA$rowsAffected != nrow(currGEA) ){
        stop("currGEA not deleted correctly")
      }
    }

    # push newGEA b/c listings may be different in terms of idx than old
    newGEA <- rbindlist(GEA_list)
    doneGEA <- labkey.importRows(baseUrl = baseUrl,
                                 folderPath = folderPath,
                                 schemaName = schemaGE,
                                 queryName = queryGEA,
                                 toImport = newGEA)

    if( doneGEA$rowsAffected != nrow(newGEA) ){
      stop("newGEA not imported correctly")
    }

    # GEAR gets deleted and then new rows imported because
    # new mappings will be different and do not want to have leftovers
    if(length(GEAR_list) != 0){
      currGEAR <- labkey.selectRows(baseUrl = baseUrl,
                                    folderPath = folderPath,
                                    schemaName = schemaGE,
                                    queryName = queryRes,
                                    colNameOpt = "rname",
                                    showHidden = T)

      if( nrow(currGEAR) != 0 ){
        delGEAR <- labkey.deleteRows(baseUrl = baseUrl,
                                     folderPath = folderPath,
                                     schemaName = schemaGE,
                                     queryName = queryRes,
                                     toDelete = currGEAR)

        suppressWarnings(postDeleteGEAR <- labkey.selectRows(baseUrl = baseUrl,
                                            folderPath = folderPath,
                                            schemaName = schemaGE,
                                            queryName = queryRes,
                                            colNameOpt = "rname",
                                            showHidden = T))

        if( nrow(postDeleteGEAR) != 0){
          stop("not all GEAR deleted correctly")
        }
      }

      # Import new GEAR
      GEAR <- rbindlist(GEAR_list)
      GEAR[ is.na(GEAR) ] <- ""
      setnames(GEAR,
               c("FeatureId", "gene_symbol", "adj.P.Val", "AveExpr", "logFC", "P.Value", "t"),
               c("feature_id", "gene_symbol", "adj_p_val", "ave_expr", "log_fc", "p_value", "statistic"))
      toImport <- data.frame(GEAR, stringsAsFactors = F)
      resGEAR <- labkey.importRows(baseUrl = baseUrl,
                                   folderPath = folderPath,
                                   schemaName = schemaGE,
                                   queryName = queryRes,
                                   toImport = toImport)
    }
}
```

```{r new-analysis}
datatable(GEA)
```

```{r staticRender, results='asis'}
cat("<script>window.HTMLWidgets.staticRender();</script>")
```

