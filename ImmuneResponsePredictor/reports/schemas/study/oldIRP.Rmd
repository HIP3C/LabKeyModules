```{r dev, echo = FALSE, eval = FALSE}
#labkey.url.base <- "test.immunespace.org"
#labkey.url.path <- "Studies/SDY269"
#labkey.file.root <- "~/Downloads/"
```

```{r knitr-opts, echo = FALSE, message = FALSE, cache = FALSE}
library(knitr)
opts_chunk$set(cache=FALSE, echo=FALSE, message=FALSE, warning=FALSE,
               fig.width=8, fig.height=4, dpi=100, fig.align="center",
               cache.path=file.path(labkey.file.root, "cache/ImmuneResponsePredictor/", labkey.user.email, ""))
```

```{r libraries, echo = FALSE, message = FALSE, cache = FALSE}
library(data.table)
library(Rlabkey)
library(ggplot2)
library(glmnet)
library(pheatmap)
library(RColorBrewer)
library(RJSONIO)
library(ImmuneSpaceR)
library(Biobase)
```

```{r plot-styles, echo = FALSE, cache = TRUE}
palette <- ISpalette(20)
```

```{r envir-var, echo = FALSE, cache=FALSE}
param <- list(
  timepoint       = as.numeric(labkey.url.params$timePoint),
  timepointUnit   = labkey.url.params$timePointUnit,
  cohortsTraining = fromJSON(labkey.url.params$cohortsTraining),
  cohortsTesting  = fromJSON(labkey.url.params$cohortsTesting),
  #GEA_acc         = fromJSON(labkey.url.params$analysisAccession),

  dichotomize     = as.logical(labkey.url.params$dichotomize),
  dichValue       = as.numeric(labkey.url.params$dichotomizeValue),
  FC_thresh       = as.numeric(labkey.url.params$fcThreshold),
  FDR_thresh      = as.logical(labkey.url.params$fdr)
)
```

```{r param, cache=TRUE, cache.extra=digest::digest(param)}
```

```{r functions, echo = FALSE, cache = TRUE}
get_FC <- function(EM, pdata, timepoint){
  FC <- EM[pdata[study_time_collected == timepoint, biosample_accession], ] - EM[pdata[study_time_collected == 0, biosample_accession],]
  rownames(FC) <- pdata[match(rownames(FC), biosample_accession), participant_id]
  return(FC)
}

get_HAI <- function(pdata, dichotomize, di_value){
  HAI_filter <- makeFilter(c("participant_id", "IN", paste(pdata$participant_id, collapse=";")))
  HAI <- data.table(labkey.selectRows(baseUrl=labkey.url.base, schemaName="study", folderPath=labkey.url.path, queryName ="hai", viewName = "full", colNameOpt="rname", colFilter=HAI_filter))
  HAI <- HAI[participant_id %in% pdata$participant_id]
  HAI <- HAI[,list(arm_accession, study_time_collected=study_time_collected, response=value_reported/value_reported[study_time_collected==0]),by="virus_strain,participant_id"]
  HAI <- HAI[study_time_collected==28]
  HAI <- HAI[,list(response=log2(max(response))),by="participant_id,arm_accession"]
  if(dichotomize){
    HAI <- HAI[,response:=ifelse(response>=log2(di_value), TRUE,  FALSE)]
  }
  cohorts <- unique(pdata[, list(cohort, participant_id)])
  HAI <- merge(HAI, cohorts, by = "participant_id")
  HAI <- HAI[order(participant_id)]
  return(HAI)
}

select_features <- function(FC, response, dichotomize, available_features){
  print(dim(FC))
  # Elastic net
  if(dichotomize){
    fit <- glmnet(FC, as.factor(response), alpha = 0.5, family = "binomial") 
  } else{
    fit <- glmnet(FC, response, alpha = 0.5)
  }
  cv_fit <- cv.glmnet(FC, response)
  coef <- predict(fit, s=cv_fit$lambda.min, type="coefficients")
  # Selecting features
  selected_features <- names(which(abs(coef[,1]) > 0))
  print("_______________")
  print(selected_features)
  selected_features <- grep("Intercept", selected_features, invert = TRUE, value = TRUE)
  selected_features <- selected_features[selected_features %in% available_features]
  if(length(selected_features) < 2){
    opts_chunk$set(eval=FALSE, cache=FALSE)
    stop("No features were selected as predictive. You may try to remove the fold change filtering under 'Additional options'.")
  }
  # Need more obs than features
  nFeatures <- length(selected_features)
  nObs <- length(response)
  if(nObs <= nFeatures){
    cat("You selected as many or more features (", nFeatures, ") than observations (", nObs, ").\nThe", nObs-2, "most significant features will be kept.\n")
    selected_features <- names(sort(coef[selected_features,])[1:(nObs-2)])
  }
  return(selected_features)
}

# Heatmap #FC_selected, HAI, palette, dichotomize
draw_heatmap <- function(FC_selected, HAI, dichotomize, palette){
  if(length(unique(HAI$type)) > 1){
    annotation <- HAI[, list(participant_id, response, cohort, type)]
    annotation <- annotation[order(response, cohort, participant_id)]
    annotation <- data.frame(annotation[order(type, decreasing = TRUE)])
  } else{
    annotation <- HAI[, list(participant_id, response, cohort)]
    annotation <- data.frame(annotation[order( response, cohort, participant_id)])
  }
  rownames(annotation) <- annotation$participant_id
  annotation$participant_id <- NULL
  if(dichotomize){
    annotation$response <- as.factor(annotation$response)
    anno_col <- list(response=c(`FALSE`="white", `TRUE`="black"))
  } else{
    anno_col <- list(response=grey(10:0/10))
  }
  mat <- t(FC_selected)
  mat <- mat[, match(rownames(annotation), colnames(mat))]
  max_FC <- max(abs(mat))
  rownames(mat) <- ifelse(nchar(rownames(mat)) > 15, paste0(substr(rownames(mat), 1, 15), "..."), rownames(mat))
  pheatmap(mat, dendrogram = "none", cluster_cols = FALSE, cluster_rows = TRUE,
           #breaks = seq(-max_FC, max_FC, length.out = length(palette) +1),
           color = palette, show_colnames = FALSE, scale = "row", 
           cluster_distance="correlation", cluster_method = "ward",
           annotation = annotation, annotation_colors = anno_col)
}

format_table <- function(x, ...){
  require(knitr)
  require(data.table)
  if(!is(x,"data.table")){
    #This is to make sure that we don't have issues with row names in data.frames
    stop("This function only works on data.tables")
  }
  out <- kable(x, format="html", digits=4, table.attr = 'class="display" id="res_table"', output = FALSE, escape = FALSE, ...)
  footer <- paste0("</thead>\n<tfoot>", strsplit(strsplit(out,"<thead>")[[1]][2],"</thead>")[[1]][1], "</tfoot>\n")
  out_new <- gsub("</thead>",footer,out)
  cat(out_new)
}
```

```{r funcs2, echo = FALSE}
getRun <- function(con, cohort){
  gem <- con$data_cache$GE_inputs
  run <- gsub(".tsv$", "", unique(gem[ gem$cohort %in% cohort, "name"]))
  return(run)
}

# Get the hai response at peak immunogenicity for a subject list
# @value A data.table with response and participant_id, ordered by subject (i.e: same order as FC or matrix)
getHAI <- function(con, subjects, dichotomize, dichValue){
  hai <- con$getDataset("hai", original_view = TRUE, reload = TRUE)
  hai <- hai[participant_id %in% subjects]
  hai <- hai[, list(arm_accession, study_time_collected, study_time_collected_unit,
                    response = value_reported/mean(value_reported[study_time_collected<=0])),
               by = "virus_strain,participant_id"]
  hai <- hai[, mr := mean(response), by="study_time_collected"]
  hai <- hai[, ma := max(mr), by = "arm_accession"]
  peak <- unique(hai[mr ==ma, list(study_time_collected, arm_accession)])
  hai <- merge(hai, peak, by=c("study_time_collected", "arm_accession"))
  #immuno_peak <- hai[hai[, mr == max(mr)], study_time_collected]
  #hai <- hai[study_time_collected == immuno_peak]
  hai <- hai[, list(response=log2(max(response))), by="participant_id"]
  if(dichotomize){
    hai <- hai[,response:=ifelse(response>=log2(dichValue), TRUE,  FALSE)]
  }
  hai <- hai[order(participant_id)]
  return(hai)
}

#getGenes <- function(con, GEA_acc, FDR_thresh, FC_thresh){
#  #if FDR_thresh: filter GEA_acc
#  if(FDR_thresh){
#    DEG <- con$getGEAnalysis(GEA_acc)
#print(DEG)
#    setnames(DEG, "log_fold-change", "log_fc")
#    DEG <- DEG[abs(log_fc) > FC_thresh]
#    DEG <- unique(DEG$gene_symbol)
#    if(length(DEG) == 0){
#      opts_chunk$set(cache=FALSE, echo=FALSE, eval=FALSE)
#      stop("\n\nThere are 0 genes selected. Try removing the filter on differentially expressed probes in 'Additional options' or lower the log fold-change threshold.")
#    }
#  } else{
#    DEG <- NULL
#  }
#  return(DEG)
#}

# @return A list of DEGs if the FDR checkbox (Additional options is checked) or NULL.
getGenes <- function(con, param, FDR_thresh, FC_thresh){
  if(FDR_thresh){
    cf <- makeFilter(c("analysis_accession/arm_name", "IN",
                        paste(c(param$cohortsTraining, param$cohortsTesting), collapse = ";")),
                     c("analysis_accession/coefficient", "EQUAL", paste(param$timepoint, param$timepointUnit)))
    DEG <- con$getGEAnalysis(colFilter = cf)
    setnames(DEG, "log_fold-change", "log_fc")
    DEG <- DEG[abs(log_fc) > FC_thresh]
    DEG <- unique(DEG$gene_symbol)
    if(length(DEG) == 0){
      opts_chunk$set(cache=FALSE, echo=FALSE, eval=FALSE)
      stop("\n\nThere are 0 genes selected. Try removing the filter on differentially expressed probes in 'Additional options' or lower the log fold-change threshold.")
    }
  } else{
    DEG <- NULL
  }
  return(DEG)
}
```


```{r main, cache = FALSE}
con <- CreateConnection()
EM <- con$getGEMatrix(cohort = param$cohortsTraining, summary = TRUE, reload = TRUE)
#if(param$timepoint >0){
#  TP <- c(0, param$timepoint)
#} else{
#  TP <- param$timepoint
#}
##EM <- EM[, pData(EM)$study_time_collected == param$timepoint & tolower(pData(EM)$study_time_collected_unit) == param$timepointUnit]
#EM <- EM[, pData(EM)$study_time_collected %in% TP & tolower(pData(EM)$study_time_collected_unit) == param$timepointUnit]
DEG <- getGenes(con, param, param$FDR_thresh, param$FC_thresh)
```
```{r main2, cache = FALSE}
if(!is.null(DEG)){
  EM <- EM[fData(EM)$gene_symbol %in% DEG,]
}
if(param$timepoint > 0){
  pdata <- data.table(pData(EM))
  pdata <- pdata[study_time_collected %in% c(0, param$timepoint) & tolower(study_time_collected_unit) == param$timepointUnit]
  subs <- pdata[, .N, by = "participant_id"][N>1, participant_id]
  pdata <- pdata[participant_id %in% subs]
  pdata <- pdata[order(participant_id, study_time_collected)]
  training_data <- exprs(EM[, pdata[study_time_collected == param$timepoint, biosample_accession]]) -
                   exprs(EM[, pdata[study_time_collected == 0, biosample_accession]])
  training_data <- t(training_data)
  print(dim(training_data))
  if(is.null(DEG) & param$FC_thresh > 0){ #i.e: not using the GEAR but using a FC thresh on the matrix
  print("DEG = NULL & FC_thresh on")
    training_data <- training_data[, log(apply(abs(training_data), 2, max)) > param$FC_thresh, drop = FALSE]
  print(dim(training_data))
    if(ncol(training_data) <= 1){
      opts_chunk$set(cache=FALSE, echo=FALSE, eval=FALSE)
      stop("\n\nAt least two genes are required for prediction. Try lowering or diabling the log fold-change filter in the 'Additional options' section to increase the number of selected genes.")
    }
  }
  rownames(training_data) <- pdata[match(rownames(training_data), pdata$biosample_accession), participant_id]
} else{
  pdata <- data.table(pData(EM))
  pdata <- pdata[study_time_collected == param$timepoint & tolower(study_time_collected_unit) == param$timepointUnit]
  EM <- EM[, pdata$biosample_accession]
  subs <- pdata$participant_id
  HAI <- getHAI(con, subs, param$dichotomize, param$dichValue)
  HAI <- HAI[, cohort := pdata$cohort]
  response <- HAI$response
  colnames(exprs(EM)) <- subs
  training_data <- t(exprs(EM))
}
HAI <- getHAI(con, subs, param$dichotomize, param$dichValue)
HAI <- HAI[, cohort := pdata[match(HAI$participant_id, pdata$participant_id), cohort]]
print(HAI)
print(EM)
print(training_data[1:4, 1:4])
response <- HAI$response


```
```{r select-features, cache = FALSE}
if(length(param$cohortsTesting) > 0){
  EM_pred <- con$getGEMatrix(cohort = param$cohortsTesting, summary = TRUE)
  available_features <- fData(EM_pred)$gene_symbol #Only consider features available in both training and testing
}
selected_features <- select_features(training_data, response, param$dichotomize, available_features)

```{r lasso, cache = FALSE}
FC_selected <- training_data[,selected_features]

# lasso #IN FC_selected, dichotomize, selected_features #OUT predictor_table
FC_selected <- data.frame(FC_selected, check.names = FALSE)
colnames(FC_selected) <- gsub("@", "", gsub(";", "_OR_", gsub("-", "_", colnames(FC_selected)))) # TODO: No need for @ / _OR_
form <- as.formula(paste0("outcome~`", paste(colnames(FC_selected), collapse="`+`"), sep="`"))
FC_selected$outcome <- response
if(param$dichotomize){
     relasso <- glm(form, FC_selected, family="binomial")
} else{
     relasso <- lm(form, FC_selected)
}

FC_selected$outcome <- NULL
sum_relasso <- summary(relasso)
sum_relasso_coef <- sum_relasso$coefficients
pred_cIdx <- grep("value|Pr", colnames(sum_relasso_coef))
predictor_table <- sum_relasso_coef[,pred_cIdx][-1,]
colnames(predictor_table) <- c("statistic", "p-value")
predictor_table <- data.table(cbind(selected_features, predictor_table))
predictor_table <- predictor_table[, `:=`(c("statistic", "p-value"), list(as.numeric(statistic), as.numeric(`p-value`)))]
predictor_table <- predictor_table[, gene_symbol := selected_features]
predictor_table <- predictor_table[, gene_symbol := sapply(strsplit(as.character(selected_features), split=";"), function(X){ paste0('<a href="http://immunet-dev.princeton.edu/predictions/gene/?network=immune_global&gene=', X, '" target="_blank">', X, '</a>', collapse=";")})]
predictor_table <- predictor_table[, selected_features := NULL]
setcolorder(predictor_table,  c("gene_symbol", "statistic", "p-value"))
```

```{r pred-cohort}
if(length(param$cohortsTesting) > 0){
  EM_pred <- EM_pred[selected_features,]
  if(param$timepoint <= 0){
    EM_pred <- EM_pred[, EM_pred$study_time_collected == param$timepoint]
    EM_pred <- EM_pred[, pData(EM_pred)$study_time_collected == param$timepoint &
                         tolower(pData(EM_pred)$study_time_collected_unit) == param$timepointUnit]
    pdata <- data.table(pData(EM_pred))
    subs <- pdata$participant_id
    data_pred <- t(exprs(EM_pred))
    rownames(data_pred) <- pdata[match(rownames(data_pred), pdata$biosample_accession), participant_id]
  } else{ #Need FC
    pdata <- data.table(pData(EM_pred))
    pdata <- pdata[study_time_collected %in% c(0, param$timepoint) & tolower(study_time_collected_unit) == param$timepointUnit]
    subs <- pdata[, .N, by = "participant_id"][N>1, participant_id]
    pdata <- pdata[participant_id %in% subs]
    pdata <- pdata[order(participant_id, study_time_collected)]
    data_pred <- exprs(EM_pred[, pdata[study_time_collected == param$timepoint, biosample_accession]]) -
          exprs(EM_pred[, pdata[study_time_collected == 0, biosample_accession]])
    data_pred <- t(data_pred)
    rownames(data_pred) <- pdata[match(rownames(data_pred), pdata$biosample_accession), participant_id]
  }
  colnames(data_pred) <- colnames(FC_selected) #Handles the -/_@ issues
  HAI_pred <- getHAI(con, subs, param$dichotomize, param$dichValue)
  HAI_pred <- HAI_pred[, cohort := pdata[, cohort]]
}
```
<br><br>

## Predicted response vs. observed response per subject
```{r prediction, echo = FALSE, dev='CairoPNG'}
# Prediction
if(length(param$cohortsTesting) == 0){
     data <- data.frame(observed = response, fitted=relasso$fitted.values)
   p<- ggplot(data, aes(x=observed, y=fitted)) + geom_point() + geom_smooth(method="lm")
} else{
  data_pred <- data.frame(data_pred)
  predicted_val <- predict(relasso, newdata = data_pred, type = "response")
  data <- data.frame(observed = c(HAI$response, HAI_pred$response),
                     fitted = c(relasso$fitted.values, predicted_val),
                     cohort = c(paste("a:", HAI$cohort, "(Training)"), paste("b:", HAI_pred$cohort, "(Testing)")))
  p<- ggplot(data, aes(x=observed, y=fitted)) + geom_point() + geom_smooth(method="lm") +
    facet_wrap(~cohort, scale="free") + xlab("Observed HAI response") + ylab("Predicted HAI response")
}
  ggthemr('solarized')
  plot(p)
  
```
<br><br>

## Heatmap of the selected genes
```{r heatmap}
HAI$type <- "Training set"
if(length(param$cohortsTesting) == 0){
  draw_heatmap(FC_selected, HAI, param$dichotomize, palette)
} else{
  HAI_pred$type <- "Testing set"
  draw_heatmap(rbind(FC_selected, data_pred), rbind(HAI, HAI_pred), param$dichotomize, palette)
}
```
<br><br>

## Table of genes selected by the Elastic Net
```{r kable, results = 'asis'}
format_table(predictor_table)
```
